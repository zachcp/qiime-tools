import pandas as pd
import click

@click.command()
@click.option('--otufilename', type=click.Path(exists=True), help="name of the otufile")
@click.option('--ucfilename', type=click.Path(exists=True), help="name of of the UC file")
@click.option('--outfile', prompt=True, help="name of the new UCfile")
def merge_OTU_UCfile(otufilename, ucfilename, outfile):
	"""
	This function performs a groupby operation on an OTU tale, using groups (clusters)
	obtained from a Usearch OTU file. The logic here is to be able to cluster sequences using
	usearch and compress the OTU file correspondingly.

	:param otufilename: a tab-delimited otutable output, probably generated by phyloseq
	:param ucfilename: a suearch uc file
	:return: an otu file where OTUS have been clustered based on membership in the UCfile.
	"""

	#load/process the OTUS and UC data
	otus = pd.read_table(otufilename)
	#handle otu files that have already been clustered
	if otus.index[0] == 'target':
		otus = otus.set_index('target')
	#otus = fixindex(otus)
	uc_data = process_uc(ucfilename)

	# the index values of the otutable should match exactly the
	# query values of the output
	assert(len(set(otus.index).difference(set(uc_data['query']))) == 0)
	#assert(set(otus.index) == set(uc_data['query']))

	mdf = pd.merge(otus, uc_data, left_index = True, right_on="query", how="left")
	mdf = mdf.set_index("query")
	mdf = mdf.groupby("target").apply(returntopsums)
	mdf = mdf.reset_index().drop('query', axis=1).set_index('target')
	mdf.to_csv(outfile, sep="\t")


def load_ucfile(filename):
	"""

	See http://www.drive5.com/usearch/manual/opt_uc.html for
	more information about UC files.

	:param filename:
	:return: standard datafrme with usearch columns
	"""
	col_names = ['rectype', 'clusternum', 'seqlength_clustsize', 'percent_ident',
				 'strand', 'nothing1','nothing2', 'compressed_algn', 'query', 'target']
	df = pd.read_table(filename, names = col_names)
	return df

def process_uc(filename):
	"""
	Load a UC file and obtain the cluster information. By grouping
	on the 'query' and 'target' columns we are able to obtain the
	1-to-1 relationship between input sequences (query) and cluster
	centroids (target).

	See http://www.drive5.com/usearch/manual/opt_uc.html for
	more information about UC files.

	:param filename:
	:return: two column data frame with query and target columns representing the start and finish OTUs
	"""

	def fixtargetcolumns(row):
		if row.target == "*":
			return row.query
		else:
			return row.target

	df = load_ucfile(filename)
	df['target'] = df.apply(fixtargetcolumns,axis=1)

	counts = df.groupby(['query', 'target']).count().reset_index()
	return counts[['query','target']]


def returntopsums(group):
	"""
	This function applies will group OTU s that belong to the
	same cluster. It returns a simple sum of the columns but replaces the index
	value with the OTUID from the OTU withth ehighest number of reads

	:param group:
	:return:  single row dataframe with index of max OTUID and column sums of the group
	"""
	if group.shape[0] == 1:
		# return single rows
		return group.drop('target',axis=1)
	else:
		#if multiple row, return the sums

		#calculate OTU with most sums
		g1 = group.drop('target', axis=1)
		sums = g1.sum(axis=1)
		maxindex = sums.idxmax()

		#get samplesums and add the index
		samplesums = g1.sum(axis=0)
		return pd.DataFrame(samplesums, columns=[maxindex]).T


def fixindex(df):
	"""

	:param df:
	:return:
	"""
	def format(x):
		x_int = int(x.replace("Seq_",""))
		return "Seq_{0:07d}".format(x_int)

	idx = list(df.index)
	df.index = map(format, idx)
	df['query'] = df.index
	return df
